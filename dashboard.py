"""
Streamlit Dashboard for Predictive Maintenance
Delta Industries Ltd.

Interactive dashboard for project evaluation featuring:
- RUL predictions (primary focus)
- Failure flags and risk categories (primary focus)
- Machine health overview
- Actionable maintenance recommendations
- Cost-benefit analysis
- Model performance metrics
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import warnings
import joblib
from sklearn.metrics import (
    mean_absolute_error,
    mean_squared_error,
    r2_score,
    roc_auc_score,
    precision_score,
    recall_score,
    confusion_matrix,
)
import subprocess
import os

warnings.filterwarnings('ignore')

# Page configuration
st.set_page_config(
    page_title="Delta Industries - Predictive Maintenance",
    page_icon=None,
    layout="wide",
    initial_sidebar_state="expanded"
)

# Modern CSS styling
st.markdown("""
    <style>
    .main-header {
        font-size: 2.8rem;
        font-weight: 700;
        color: #1a1a1a;
        text-align: center;
        margin-bottom: 0.5rem;
        letter-spacing: -0.02em;
    }
    .subheader {
        font-size: 1.1rem;
        color: #666;
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 400;
    }
    .info-card {
        background: linear-gradient(135deg, #f5f7fa 0%, #ffffff 100%);
        padding: 1.5rem;
        border-radius: 12px;
        border: 1px solid #e1e8ed;
        box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        margin-bottom: 1rem;
    }
    .info-card h4 {
        color: #1a1a1a;
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
        margin-top: 0;
    }
    .info-card p {
        color: #4a5568;
        font-size: 0.95rem;
        line-height: 1.6;
        margin: 0;
    }
    .metric-container {
        background: #ffffff;
        padding: 1.25rem;
        border-radius: 10px;
        border: 1px solid #e1e8ed;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .section-header {
        font-size: 1.5rem;
        font-weight: 600;
        color: #1a1a1a;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #e1e8ed;
    }
    .cost-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 12px;
        margin: 1rem 0;
    }
    .cost-box h3 {
        color: white;
        margin: 0 0 1rem 0;
        font-size: 1.3rem;
    }
    .cost-metric {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem 0;
        border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    .cost-metric:last-child {
        border-bottom: none;
        font-weight: 600;
        font-size: 1.1rem;
        margin-top: 0.5rem;
    }
    </style>
""", unsafe_allow_html=True)

@st.cache_data
def load_dashboard_data():
    """Load dashboard outputs CSV."""
    try:
        df = pd.read_csv('outputs/dashboard_outputs.csv')
        df['snapshot_date'] = pd.to_datetime(df['snapshot_date'])
        return df
    except FileNotFoundError:
        st.error("Dashboard outputs file not found. Please run 'python3 generate_dashboard_outputs.py' first.")
        st.stop()


@st.cache_data
def load_raw_dataset():
    """Load the base machine health dataset generated by data_generation.py."""
    try:
        df = pd.read_csv('outputs/delta_industries_machine_health.csv')
        df['snapshot_date'] = pd.to_datetime(df['snapshot_date'])
        return df
    except FileNotFoundError:
        return None


@st.cache_resource
def load_models():
    """Load trained models and scalers for on-dashboard evaluation."""
    try:
        rul_model = joblib.load('outputs/rul_model.pkl')
        rul_scaler = joblib.load('outputs/rul_scaler.pkl')
        failure_model = joblib.load('outputs/failure_risk_model.pkl')
        failure_scaler = joblib.load('outputs/failure_risk_scaler.pkl')
        return rul_model, rul_scaler, failure_model, failure_scaler
    except FileNotFoundError:
        return None, None, None, None


@st.cache_data
def compute_model_metrics():
    """
    Compute key regression and classification metrics plus confusion matrix
    using the full dataset and saved models.
    """
    base_df = load_raw_dataset()
    rul_model, rul_scaler, failure_model, failure_scaler = load_models()

    if base_df is None or rul_model is None or failure_model is None:
        return None

    # Prepare features (same logic as modeling.py / generate_dashboard_outputs.py)
    df_encoded = pd.get_dummies(base_df, columns=['machine_type'], prefix='type', drop_first=True)
    exclude_cols = ['machine_id', 'snapshot_date', 'RUL_days', 'fail_in_30d']
    feature_cols = [col for col in df_encoded.columns if col not in exclude_cols]
    X = df_encoded[feature_cols]

    # True targets
    y_rul = base_df['RUL_days'].values
    y_failure = base_df['fail_in_30d'].values

    # RUL metrics
    X_rul_scaled = rul_scaler.transform(X)
    rul_pred = rul_model.predict(X_rul_scaled)
    rul_mae = mean_absolute_error(y_rul, rul_pred)
    rul_rmse = np.sqrt(mean_squared_error(y_rul, rul_pred))
    rul_r2 = r2_score(y_rul, rul_pred)

    # Failure classification metrics
    X_fail_scaled = failure_scaler.transform(X)
    failure_proba = failure_model.predict_proba(X_fail_scaled)[:, 1]
    failure_pred = failure_model.predict(X_fail_scaled)

    auc = roc_auc_score(y_failure, failure_proba)
    precision = precision_score(y_failure, failure_pred)
    recall = recall_score(y_failure, failure_pred)
    cm = confusion_matrix(y_failure, failure_pred)

    # Cost-benefit analysis
    tp = cm[1, 1]
    fp = cm[0, 1]
    fn = cm[1, 0]
    tn = cm[0, 0]
    
    planned_maintenance_cost = (tp + fp) * 2000
    prevented_downtime_savings = tp * 10000
    missed_failures_cost = fn * (10000 + 5000)  # Downtime + emergency repair
    net_benefit = prevented_downtime_savings - planned_maintenance_cost - missed_failures_cost

    metrics = {
        "rul": {
            "mae": rul_mae,
            "rmse": rul_rmse,
            "r2": rul_r2,
        },
        "failure": {
            "auc": auc,
            "precision": precision,
            "recall": recall,
            "confusion_matrix": cm,
        },
        "cost_benefit": {
            "planned_maintenance_cost": planned_maintenance_cost,
            "prevented_downtime_savings": prevented_downtime_savings,
            "missed_failures_cost": missed_failures_cost,
            "net_benefit": net_benefit,
            "tp": int(tp),
            "fp": int(fp),
            "fn": int(fn),
            "tn": int(tn),
        }
    }
    return metrics


def get_color_for_risk(risk_category):
    """Return color code for risk category."""
    colors = {
        'RED': '#d32f2f',
        'YELLOW': '#f57c00',
        'GREEN': '#388e3c'
    }
    return colors.get(risk_category, '#757575')


def run_full_pipeline():
    """
    Regenerate data, retrain models, and recreate dashboard outputs by
    calling run_all.py. This keeps the dashboard in sync with new data.
    """
    with st.spinner("Running full pipeline (data generation, EDA, modeling, evaluation, dashboard outputs)..."):
        try:
            # Ensure we run from project root
            project_root = os.path.dirname(os.path.abspath(__file__))
            result = subprocess.run(
                ["python3", "run_all.py"],
                cwd=project_root,
                capture_output=True,
                text=True,
                check=True,
            )
            st.success("Full pipeline completed successfully. Dashboard data refreshed.")
            with st.expander("Show pipeline logs"):
                st.text(result.stdout)
                if result.stderr:
                    st.text("\n[stderr]\n" + result.stderr)
        except subprocess.CalledProcessError as e:
            st.error("Pipeline execution failed. Please check the logs below.")
            with st.expander("Show error details"):
                st.text(e.stdout or "")
                st.text("\n[stderr]\n" + (e.stderr or ""))


def main():
    # Header
    st.markdown('<div class="main-header">Delta Industries - Predictive Maintenance Dashboard</div>', unsafe_allow_html=True)
    st.markdown('<div class="subheader">Remaining Useful Life (RUL) Prediction and Failure Risk Assessment System</div>', unsafe_allow_html=True)
    st.markdown("---")
    
    # Load data
    df = load_dashboard_data()
    base_df = load_raw_dataset()
    model_metrics = compute_model_metrics()
    
    # Sidebar controls: data actions + filters
    st.sidebar.header("Data & Pipeline Controls")
    col_generate, col_download = st.sidebar.columns(2)
    with col_generate:
        if st.button("Run Pipeline", help="Regenerate data, retrain models, and refresh dashboard outputs.", use_container_width=True):
            run_full_pipeline()
            # Clear caches so fresh data is used on next rerun
            load_dashboard_data.clear()
            load_raw_dataset.clear()
            compute_model_metrics.clear()
            st.rerun()
    with col_download:
        if base_df is not None:
            st.download_button(
                label="Download CSV",
                data=base_df.to_csv(index=False),
                file_name="delta_industries_machine_health.csv",
                mime="text/csv",
                help="Download the underlying machine health dataset.",
                use_container_width=True,
            )
        else:
            st.caption("Base dataset not found yet. Run the pipeline first.")
    
    # Sidebar filters
    st.sidebar.header("Filters")
    
    # Machine type filter
    machine_types = ['All'] + sorted(df['machine_type'].unique().tolist())
    selected_machine_type = st.sidebar.selectbox("Machine Type", machine_types)
    
    # Risk category filter
    risk_categories = ['All'] + sorted(df['risk_category'].unique().tolist())
    selected_risk = st.sidebar.selectbox("Risk Category", risk_categories)
    
    # Criticality filter
    criticality_scores = ['All'] + sorted(df['criticality_score'].unique().tolist())
    selected_criticality = st.sidebar.selectbox("Criticality Score", criticality_scores)
    
    # Failure flag filter
    failure_flag_filter = st.sidebar.selectbox("Failure Flag", ['All', 'Flagged (1)', 'Not Flagged (0)'])
    
    # Apply filters
    filtered_df = df.copy()
    if selected_machine_type != 'All':
        filtered_df = filtered_df[filtered_df['machine_type'] == selected_machine_type]
    if selected_risk != 'All':
        filtered_df = filtered_df[filtered_df['risk_category'] == selected_risk]
    if selected_criticality != 'All':
        filtered_df = filtered_df[filtered_df['criticality_score'] == selected_criticality]
    if failure_flag_filter == 'Flagged (1)':
        filtered_df = filtered_df[filtered_df['failure_flag'] == 1]
    elif failure_flag_filter == 'Not Flagged (0)':
        filtered_df = filtered_df[filtered_df['failure_flag'] == 0]
    
    # Information Cards Section
    st.markdown('<div class="section-header">Project Overview</div>', unsafe_allow_html=True)
    info_col1, info_col2, info_col3 = st.columns(3)
    
    with info_col1:
        st.markdown("""
        <div class="info-card">
            <h4>Dataset</h4>
            <p>Synthetic machine-health data for Delta Industries with weekly snapshots per machine. 
            Includes sensor readings (temperature, vibration, pressure, load factor), machine metadata 
            (type, age, maintenance history), and engineered targets for remaining useful life (RUL) 
            and 30-day failure risk prediction.</p>
        </div>
        """, unsafe_allow_html=True)
    
    with info_col2:
        st.markdown("""
        <div class="info-card">
            <h4>Models</h4>
            <p>Two complementary models: Linear Regression predicts continuous RUL in days for 
            maintenance planning, while Logistic Regression estimates binary failure probability 
            (within 30 days) for risk-based decision making. Both use scaled numerical features 
            and one-hot encoded machine types.</p>
        </div>
        """, unsafe_allow_html=True)
    
    with info_col3:
        st.markdown("""
        <div class="info-card">
            <h4>Business Logic</h4>
            <p>Risk categories: RED (urgent, failure_prob ≥ 70% or RUL ≤ 30 days), YELLOW 
            (schedule maintenance, failure_prob ≥ 40% or RUL ≤ 60 days), GREEN (monitor only). 
            Cost assumptions: $2,000 planned maintenance, $10,000 unplanned downtime, $5,000 
            emergency repair per machine.</p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Key Metrics Row
    st.markdown('<div class="section-header">Key Metrics</div>', unsafe_allow_html=True)
    col1, col2, col3, col4 = st.columns(4)
    
    # Fix: Count unique machines, not total rows
    unique_machines = filtered_df['machine_id'].nunique()
    total_unique_machines = df['machine_id'].nunique()
    
    with col1:
        st.metric("Total Machines", unique_machines, delta=f"{unique_machines - total_unique_machines}" if unique_machines != total_unique_machines else None)
    
    with col2:
        red_machines = filtered_df[filtered_df['risk_category'] == 'RED']
        red_count = red_machines['machine_id'].nunique() if len(red_machines) > 0 else 0
        total_red = df[df['risk_category'] == 'RED']['machine_id'].nunique() if len(df[df['risk_category'] == 'RED']) > 0 else 0
        st.metric("At Risk (RED)", red_count, delta=f"{red_count - total_red}" if red_count != total_red else None)
    
    with col3:
        avg_rul = filtered_df['RUL_days_predicted'].mean()
        st.metric("Average RUL", f"{avg_rul:.1f} days")
    
    with col4:
        avg_failure_prob = filtered_df['failure_probability'].mean()
        st.metric("Avg Failure Probability", f"{avg_failure_prob:.1%}")
    
    st.markdown("---")
    
    # Main Dashboard Sections
    # Row 1: RUL Overview and Failure Risk Distribution
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown('<div class="section-header">RUL Overview</div>', unsafe_allow_html=True)
        
        # RUL Distribution Histogram
        fig_rul_hist = px.histogram(
            filtered_df,
            x='RUL_days_predicted',
            nbins=30,
            title='RUL Distribution',
            labels={'RUL_days_predicted': 'Remaining Useful Life (Days)', 'count': 'Number of Snapshots'},
            color_discrete_sequence=['#667eea']
        )
        fig_rul_hist.add_vline(x=30, line_dash="dash", line_color="#d32f2f", annotation_text="30 days threshold", annotation_position="top")
        fig_rul_hist.add_vline(x=60, line_dash="dash", line_color="#f57c00", annotation_text="60 days threshold", annotation_position="top")
        fig_rul_hist.update_layout(
            height=400,
            plot_bgcolor='white',
            paper_bgcolor='white',
            font=dict(size=11)
        )
        st.plotly_chart(fig_rul_hist, use_container_width=True)
        
        # RUL vs Actual RUL Comparison (if available)
        if 'actual_RUL_days' in filtered_df.columns:
            fig_rul_comparison = px.scatter(
                filtered_df,
                x='actual_RUL_days',
                y='RUL_days_predicted',
                color='risk_category',
                color_discrete_map={'RED': '#d32f2f', 'YELLOW': '#f57c00', 'GREEN': '#388e3c'},
                title='Predicted vs Actual RUL',
                labels={'actual_RUL_days': 'Actual RUL (Days)', 'RUL_days_predicted': 'Predicted RUL (Days)'},
                hover_data=['machine_id', 'failure_probability']
            )
            # Add diagonal line
            max_val = max(filtered_df['actual_RUL_days'].max(), filtered_df['RUL_days_predicted'].max())
            fig_rul_comparison.add_trace(go.Scatter(
                x=[0, max_val],
                y=[0, max_val],
                mode='lines',
                line=dict(dash='dash', color='gray', width=1),
                name='Perfect Prediction',
                showlegend=False
            ))
            fig_rul_comparison.update_layout(
                height=400,
                plot_bgcolor='white',
                paper_bgcolor='white',
                font=dict(size=11)
            )
            st.plotly_chart(fig_rul_comparison, use_container_width=True)
    
    with col2:
        st.markdown('<div class="section-header">Failure Risk Distribution</div>', unsafe_allow_html=True)
        
        # Risk Category Pie Chart
        risk_counts = filtered_df['risk_category'].value_counts()
        fig_pie = px.pie(
            values=risk_counts.values,
            names=risk_counts.index,
            title='Risk Category Distribution',
            color=risk_counts.index,
            color_discrete_map={'RED': '#d32f2f', 'YELLOW': '#f57c00', 'GREEN': '#388e3c'}
        )
        fig_pie.update_layout(
            height=400,
            plot_bgcolor='white',
            paper_bgcolor='white',
            font=dict(size=11)
        )
        st.plotly_chart(fig_pie, use_container_width=True)
        
        # Failure Probability Distribution
        fig_failure_prob = px.histogram(
            filtered_df,
            x='failure_probability',
            nbins=30,
            title='Failure Probability Distribution',
            labels={'failure_probability': 'Failure Probability', 'count': 'Number of Snapshots'},
            color='risk_category',
            color_discrete_map={'RED': '#d32f2f', 'YELLOW': '#f57c00', 'GREEN': '#388e3c'}
        )
        fig_failure_prob.add_vline(x=0.7, line_dash="dash", line_color="#d32f2f", annotation_text="70% threshold", annotation_position="top")
        fig_failure_prob.add_vline(x=0.4, line_dash="dash", line_color="#f57c00", annotation_text="40% threshold", annotation_position="top")
        fig_failure_prob.update_layout(
            height=400,
            plot_bgcolor='white',
            paper_bgcolor='white',
            font=dict(size=11)
        )
        st.plotly_chart(fig_failure_prob, use_container_width=True)
    
    st.markdown("---")
    
    # Model Performance Summary
    if model_metrics is not None:
        st.markdown('<div class="section-header">Model Performance (Full Dataset)</div>', unsafe_allow_html=True)
        col_rul, col_fail = st.columns(2)

        with col_rul:
            st.markdown("**RUL Model (Linear Regression)**")
            st.metric("MAE", f"{model_metrics['rul']['mae']:.1f} days")
            st.metric("RMSE", f"{model_metrics['rul']['rmse']:.1f} days")
            st.metric("R²", f"{model_metrics['rul']['r2']:.3f}")

        with col_fail:
            st.markdown("**Failure Risk Model (Logistic Regression)**")
            st.metric("ROC-AUC", f"{model_metrics['failure']['auc']:.3f}")
            st.metric("Precision", f"{model_metrics['failure']['precision']:.3f}")
            st.metric("Recall", f"{model_metrics['failure']['recall']:.3f}")

        # Confusion matrix heatmap
        cm = model_metrics["failure"]["confusion_matrix"]
        cm_fig = px.imshow(
            cm,
            text_auto=True,
            color_continuous_scale="Blues",
            labels=dict(x="Predicted", y="Actual", color="Count"),
            x=["Low Risk (0)", "High Risk (1)"],
            y=["Low Risk (0)", "High Risk (1)"],
        )
        cm_fig.update_layout(
            title="Failure Risk Model - Confusion Matrix",
            height=400,
            plot_bgcolor='white',
            paper_bgcolor='white',
        )
        st.plotly_chart(cm_fig, use_container_width=True)
        
        # Cost-Benefit Analysis
        st.markdown("---")
        st.markdown('<div class="section-header">Cost-Benefit Analysis</div>', unsafe_allow_html=True)
        
        cb = model_metrics['cost_benefit']
        
        cost_col1, cost_col2 = st.columns(2)
        
        with cost_col1:
            st.markdown("""
            <div class="cost-box">
                <h3>Costs</h3>
                <div class="cost-metric">
                    <span>Planned Maintenance (TP + FP)</span>
                    <span>${:,.0f}</span>
                </div>
                <div class="cost-metric">
                    <span>Missed Failures (FN)</span>
                    <span>${:,.0f}</span>
                </div>
                <div class="cost-metric">
                    <span>Total Costs</span>
                    <span>${:,.0f}</span>
                </div>
            </div>
            """.format(
                cb['planned_maintenance_cost'],
                cb['missed_failures_cost'],
                cb['planned_maintenance_cost'] + cb['missed_failures_cost']
            ), unsafe_allow_html=True)
        
        with cost_col2:
            st.markdown("""
            <div class="cost-box">
                <h3>Savings & Net Benefit</h3>
                <div class="cost-metric">
                    <span>Prevented Downtime (TP)</span>
                    <span>${:,.0f}</span>
                </div>
                <div class="cost-metric">
                    <span style="opacity: 0.8;">Total Savings</span>
                    <span>${:,.0f}</span>
                </div>
                <div class="cost-metric">
                    <span>Net Benefit (ROI)</span>
                    <span>${:,.0f}</span>
                </div>
            </div>
            """.format(
                cb['prevented_downtime_savings'],
                cb['prevented_downtime_savings'],
                cb['net_benefit']
            ), unsafe_allow_html=True)
        
        st.info(f"""
        **Cost Assumptions:** Planned maintenance: $2,000/machine | Unplanned downtime: $10,000/machine | 
        Emergency repair: $5,000/machine
        
        **Confusion Matrix Breakdown:** TP={cb['tp']} (correctly identified failures) | FP={cb['fp']} (false alarms) | 
        FN={cb['fn']} (missed failures) | TN={cb['tn']} (correctly identified safe machines)
        
        **ROI Status:** {'Positive ROI - Model provides significant value' if cb['net_benefit'] > 0 else 'Needs optimization - Consider adjusting thresholds or improving model accuracy'}
        """)
    else:
        st.info("Model performance metrics are not available yet. Run the full pipeline to train models and generate data.")
    
    st.markdown("---")
    
    # Alert Panel - RED Category Machines
    st.markdown('<div class="section-header">Urgent Action Required (RED Category)</div>', unsafe_allow_html=True)
    red_machines = filtered_df[filtered_df['risk_category'] == 'RED'].copy()
    
    if len(red_machines) > 0:
        # Get unique machines in RED category
        red_unique_machines = red_machines['machine_id'].unique()
        
        # Sort by RUL (lowest first) and failure probability (highest first)
        red_machines = red_machines.sort_values(['RUL_days_predicted', 'failure_probability'], ascending=[True, False])
        
        # Display key metrics for RED machines
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total RED Machines", len(red_unique_machines))
        with col2:
            st.metric("Lowest RUL", f"{red_machines['RUL_days_predicted'].min():.1f} days")
        with col3:
            st.metric("Highest Failure Prob", f"{red_machines['failure_probability'].max():.1%}")
        
        # Display table (show latest snapshot per machine)
        red_latest = red_machines.groupby('machine_id').first().reset_index()
        display_cols = ['machine_id', 'machine_type', 'RUL_days_predicted', 'failure_probability', 
                       'criticality_score', 'snapshot_date']
        red_display = red_latest[display_cols].copy()
        red_display['RUL_days_predicted'] = red_display['RUL_days_predicted'].round(1)
        red_display['failure_probability'] = red_display['failure_probability'].apply(lambda x: f"{x:.1%}")
        red_display['snapshot_date'] = red_display['snapshot_date'].dt.strftime('%Y-%m-%d')
        red_display.columns = ['Machine ID', 'Machine Type', 'RUL (Days)', 'Failure Probability', 
                              'Criticality', 'Snapshot Date']
        
        st.dataframe(red_display, use_container_width=True, hide_index=True)
        
        # Action recommendations
        st.info("**Action Required:** Schedule maintenance within 1 week for these machines. Prepare spare parts and assign priority technicians.")
    else:
        st.success("No machines currently in RED category. All systems operating normally.")
    
    st.markdown("---")
    
    # Machine Details Table
    st.markdown('<div class="section-header">Machine Details Table</div>', unsafe_allow_html=True)
    
    # Sort options
    sort_by = st.selectbox("Sort by", ['RUL (Lowest First)', 'RUL (Highest First)', 
                                       'Failure Probability (Highest First)', 'Failure Probability (Lowest First)',
                                       'Machine ID', 'Risk Category'])
    
    display_df = filtered_df.copy()
    
    if sort_by == 'RUL (Lowest First)':
        display_df = display_df.sort_values('RUL_days_predicted', ascending=True)
    elif sort_by == 'RUL (Highest First)':
        display_df = display_df.sort_values('RUL_days_predicted', ascending=False)
    elif sort_by == 'Failure Probability (Highest First)':
        display_df = display_df.sort_values('failure_probability', ascending=False)
    elif sort_by == 'Failure Probability (Lowest First)':
        display_df = display_df.sort_values('failure_probability', ascending=True)
    elif sort_by == 'Machine ID':
        display_df = display_df.sort_values('machine_id', ascending=True)
    elif sort_by == 'Risk Category':
        risk_order = {'RED': 1, 'YELLOW': 2, 'GREEN': 3}
        display_df['risk_order'] = display_df['risk_category'].map(risk_order)
        display_df = display_df.sort_values('risk_order', ascending=True)
        display_df = display_df.drop('risk_order', axis=1)
    
    # Prepare display columns
    table_cols = ['machine_id', 'machine_type', 'RUL_days_predicted', 'failure_probability',
                  'risk_category', 'failure_flag', 'criticality_score', 'snapshot_date']
    if 'actual_RUL_days' in display_df.columns:
        table_cols.insert(4, 'actual_RUL_days')
    
    table_df = display_df[table_cols].copy()
    table_df['RUL_days_predicted'] = table_df['RUL_days_predicted'].round(1)
    table_df['failure_probability'] = table_df['failure_probability'].apply(lambda x: f"{x:.1%}")
    if 'actual_RUL_days' in table_df.columns:
        table_df['actual_RUL_days'] = table_df['actual_RUL_days'].round(1)
    table_df['snapshot_date'] = table_df['snapshot_date'].dt.strftime('%Y-%m-%d')
    
    # Rename columns for display
    column_mapping = {
        'machine_id': 'Machine ID',
        'machine_type': 'Machine Type',
        'RUL_days_predicted': 'RUL (Days)',
        'failure_probability': 'Failure Probability',
        'risk_category': 'Risk Category',
        'failure_flag': 'Failure Flag',
        'criticality_score': 'Criticality',
        'snapshot_date': 'Snapshot Date'
    }
    if 'actual_RUL_days' in table_df.columns:
        column_mapping['actual_RUL_days'] = 'Actual RUL (Days)'
    
    table_df = table_df.rename(columns=column_mapping)
    
    # Color code the dataframe
    def color_risk_category(val):
        if val == 'RED':
            return 'background-color: #ffebee'
        elif val == 'YELLOW':
            return 'background-color: #fff3e0'
        elif val == 'GREEN':
            return 'background-color: #e8f5e9'
        return ''
    
    styled_df = table_df.style.applymap(color_risk_category, subset=['Risk Category'])
    st.dataframe(styled_df, use_container_width=True, hide_index=True)
    
    st.markdown("---")
    
    # Maintenance Schedule
    st.markdown('<div class="section-header">Maintenance Schedule</div>', unsafe_allow_html=True)
    
    # Create maintenance schedule based on RUL
    schedule_df = filtered_df.copy()
    schedule_df['recommended_maintenance_date'] = pd.to_datetime(schedule_df['snapshot_date']) + pd.to_timedelta(schedule_df['RUL_days_predicted'], unit='D')
    schedule_df['days_until_maintenance'] = (schedule_df['recommended_maintenance_date'] - pd.to_datetime('today')).dt.days
    
    # Sort by priority (RED first, then by RUL)
    risk_order = {'RED': 1, 'YELLOW': 2, 'GREEN': 3}
    schedule_df['risk_order'] = schedule_df['risk_category'].map(risk_order)
    schedule_df = schedule_df.sort_values(['risk_order', 'RUL_days_predicted'], ascending=[True, True])
    schedule_df = schedule_df.drop('risk_order', axis=1)
    
    # Show latest snapshot per machine
    schedule_latest = schedule_df.groupby('machine_id').first().reset_index()
    
    # Display schedule
    schedule_cols = ['machine_id', 'machine_type', 'RUL_days_predicted', 'failure_probability',
                    'risk_category', 'recommended_maintenance_date', 'days_until_maintenance']
    schedule_display = schedule_latest[schedule_cols].copy()
    schedule_display['RUL_days_predicted'] = schedule_display['RUL_days_predicted'].round(1)
    schedule_display['failure_probability'] = schedule_display['failure_probability'].apply(lambda x: f"{x:.1%}")
    schedule_display['recommended_maintenance_date'] = schedule_display['recommended_maintenance_date'].dt.strftime('%Y-%m-%d')
    schedule_display.columns = ['Machine ID', 'Machine Type', 'RUL (Days)', 'Failure Probability',
                                'Risk Category', 'Recommended Date', 'Days Until']
    
    st.dataframe(schedule_display.head(50), use_container_width=True, hide_index=True)
    
    st.info("**Note:** Recommended maintenance dates are calculated based on predicted RUL. Machines with RED category should be scheduled immediately.")
    
    # Footer
    st.markdown("---")
    st.markdown("**Delta Industries Ltd.** | Predictive Maintenance System | Generated for Project Evaluation")

if __name__ == "__main__":
    main()
