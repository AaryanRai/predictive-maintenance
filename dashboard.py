"""
Streamlit Dashboard for Predictive Maintenance
Delta Industries Ltd.

Interactive dashboard for project evaluation featuring:
- RUL predictions (primary focus)
- Failure flags and risk categories (primary focus)
- Machine health overview
- Actionable maintenance recommendations
- Cost-benefit analysis
- Model performance metrics
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import warnings
import joblib
from sklearn.metrics import (
    mean_absolute_error,
    mean_squared_error,
    r2_score,
    roc_auc_score,
    precision_score,
    recall_score,
    confusion_matrix,
)
import subprocess
import os

warnings.filterwarnings('ignore')

# Page configuration
st.set_page_config(
    page_title="Delta Industries - Predictive Maintenance",
    page_icon=None,
    layout="wide",
    initial_sidebar_state="expanded"
)

# Modern CSS styling for dark background with white text
st.markdown("""
    <style>
    /* Main text styling - white text for dark background */
    .main-header {
        font-size: 2.8rem;
        font-weight: 700;
        color: #ffffff;
        text-align: center;
        margin-bottom: 0.5rem;
        letter-spacing: -0.02em;
    }
    .subheader {
        font-size: 1.15rem;
        color: #e0e0e0;
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 500;
    }
    .info-card {
        background: rgba(255, 255, 255, 0.1);
        padding: 1.5rem;
        border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        margin-bottom: 1rem;
    }
    .info-card h4 {
        color: #ffffff;
        font-size: 1.2rem;
        font-weight: 700;
        margin-bottom: 0.75rem;
        margin-top: 0;
    }
    .info-card p {
        color: #e0e0e0;
        font-size: 1rem;
        line-height: 1.7;
        margin: 0;
        font-weight: 400;
    }
    .section-header {
        font-size: 1.6rem;
        font-weight: 700;
        color: #ffffff;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 3px solid #667eea;
    }
    .explanation-box {
        background: rgba(255, 255, 255, 0.05);
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #667eea;
        margin: 1rem 0;
    }
    .explanation-box p {
        color: #e0e0e0;
        font-size: 0.95rem;
        line-height: 1.6;
        margin: 0;
    }
    /* Improve Streamlit default text for dark background */
    .stMarkdown {
        color: #ffffff;
    }
    .stMarkdown h1, .stMarkdown h2, .stMarkdown h3, .stMarkdown h4 {
        color: #ffffff;
    }
    .stMetric {
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 1rem;
    }
    .stMetric label {
        color: #e0e0e0;
        font-weight: 600;
        font-size: 0.95rem;
    }
    .stMetric [data-testid="stMetricValue"] {
        color: #ffffff;
        font-weight: 700;
    }
    /* Cost breakdown styling */
    .cost-section {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 12px;
        border: 2px solid #dee2e6;
        margin: 1rem 0;
    }
    .cost-title {
        color: #000000;
        font-size: 1.3rem;
        font-weight: 700;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #667eea;
    }
    .cost-item {
        display: flex;
        justify-content: space-between;
        padding: 0.75rem 0;
        border-bottom: 1px solid #dee2e6;
        font-size: 1rem;
    }
    .cost-item-label {
        color: #1a1a1a;
        font-weight: 500;
    }
    .cost-item-value {
        color: #000000;
        font-weight: 700;
        font-size: 1.1rem;
    }
    .cost-item:last-child {
        border-bottom: none;
        border-top: 2px solid #667eea;
        margin-top: 0.5rem;
        padding-top: 1rem;
    }
    .cost-item:last-child .cost-item-label,
    .cost-item:last-child .cost-item-value {
        font-size: 1.2rem;
        font-weight: 700;
    }
    </style>
""", unsafe_allow_html=True)

@st.cache_data
def load_dashboard_data():
    """Load dashboard outputs CSV."""
    try:
        df = pd.read_csv('outputs/dashboard_outputs.csv')
        df['snapshot_date'] = pd.to_datetime(df['snapshot_date'])
        return df
    except FileNotFoundError:
        st.error("Dashboard outputs file not found. Please run 'python3 generate_dashboard_outputs.py' first.")
        st.stop()


@st.cache_data
def load_raw_dataset():
    """Load the base machine health dataset generated by data_generation.py."""
    try:
        df = pd.read_csv('outputs/delta_industries_machine_health.csv')
        df['snapshot_date'] = pd.to_datetime(df['snapshot_date'])
        return df
    except FileNotFoundError:
        return None


@st.cache_resource
def load_models():
    """Load trained models and scalers for on-dashboard evaluation."""
    try:
        rul_model = joblib.load('outputs/rul_model.pkl')
        rul_scaler = joblib.load('outputs/rul_scaler.pkl')
        failure_model = joblib.load('outputs/failure_risk_model.pkl')
        failure_scaler = joblib.load('outputs/failure_risk_scaler.pkl')
        return rul_model, rul_scaler, failure_model, failure_scaler
    except FileNotFoundError:
        return None, None, None, None


@st.cache_data
def compute_model_metrics():
    """
    Compute key regression and classification metrics plus confusion matrix
    using the full dataset and saved models.
    """
    base_df = load_raw_dataset()
    rul_model, rul_scaler, failure_model, failure_scaler = load_models()

    if base_df is None or rul_model is None or failure_model is None:
        return None

    # Prepare features (same logic as modeling.py / generate_dashboard_outputs.py)
    df_encoded = pd.get_dummies(base_df, columns=['machine_type'], prefix='type', drop_first=True)
    exclude_cols = ['machine_id', 'snapshot_date', 'RUL_days', 'fail_in_30d']
    feature_cols = [col for col in df_encoded.columns if col not in exclude_cols]
    X = df_encoded[feature_cols]

    # True targets
    y_rul = base_df['RUL_days'].values
    y_failure = base_df['fail_in_30d'].values

    # RUL metrics
    X_rul_scaled = rul_scaler.transform(X)
    rul_pred = rul_model.predict(X_rul_scaled)
    rul_mae = mean_absolute_error(y_rul, rul_pred)
    rul_rmse = np.sqrt(mean_squared_error(y_rul, rul_pred))
    rul_r2 = r2_score(y_rul, rul_pred)

    # Failure classification metrics
    X_fail_scaled = failure_scaler.transform(X)
    failure_proba = failure_model.predict_proba(X_fail_scaled)[:, 1]
    failure_pred = failure_model.predict(X_fail_scaled)

    auc = roc_auc_score(y_failure, failure_proba)
    precision = precision_score(y_failure, failure_pred)
    recall = recall_score(y_failure, failure_pred)
    cm = confusion_matrix(y_failure, failure_pred)

    # Cost-benefit analysis
    tp = cm[1, 1]
    fp = cm[0, 1]
    fn = cm[1, 0]
    tn = cm[0, 0]
    
    planned_maintenance_cost = (tp + fp) * 2000
    prevented_downtime_savings = tp * 10000
    missed_failures_cost = fn * (10000 + 5000)  # Downtime + emergency repair
    net_benefit = prevented_downtime_savings - planned_maintenance_cost - missed_failures_cost

    metrics = {
        "rul": {
            "mae": rul_mae,
            "rmse": rul_rmse,
            "r2": rul_r2,
        },
        "failure": {
            "auc": auc,
            "precision": precision,
            "recall": recall,
            "confusion_matrix": cm,
        },
        "cost_benefit": {
            "planned_maintenance_cost": planned_maintenance_cost,
            "prevented_downtime_savings": prevented_downtime_savings,
            "missed_failures_cost": missed_failures_cost,
            "net_benefit": net_benefit,
            "tp": int(tp),
            "fp": int(fp),
            "fn": int(fn),
            "tn": int(tn),
        }
    }
    return metrics


def get_color_for_risk(risk_category):
    """Return color code for risk category."""
    colors = {
        'RED': '#d32f2f',
        'YELLOW': '#f57c00',
        'GREEN': '#388e3c'
    }
    return colors.get(risk_category, '#757575')


def run_full_pipeline():
    """
    Regenerate data, retrain models, and recreate dashboard outputs by
    calling run_all.py. This keeps the dashboard in sync with new data.
    """
    with st.spinner("Running full pipeline (data generation, EDA, modeling, evaluation, dashboard outputs)..."):
        try:
            # Ensure we run from project root
            project_root = os.path.dirname(os.path.abspath(__file__))
            result = subprocess.run(
                ["python3", "run_all.py"],
                cwd=project_root,
                capture_output=True,
                text=True,
                check=True,
            )
            st.success("Full pipeline completed successfully. Dashboard data refreshed.")
            with st.expander("Show pipeline logs"):
                st.text(result.stdout)
                if result.stderr:
                    st.text("\n[stderr]\n" + result.stderr)
        except subprocess.CalledProcessError as e:
            st.error("Pipeline execution failed. Please check the logs below.")
            with st.expander("Show error details"):
                st.text(e.stdout or "")
                st.text("\n[stderr]\n" + (e.stderr or ""))


def main():
    # Header
    st.markdown('<div class="main-header">Delta Industries - Predictive Maintenance Dashboard</div>', unsafe_allow_html=True)
    st.markdown('<div class="subheader">Remaining Useful Life (RUL) Prediction and Failure Risk Assessment System</div>', unsafe_allow_html=True)
    st.markdown("---")
    
    # Load data
    df = load_dashboard_data()
    base_df = load_raw_dataset()
    model_metrics = compute_model_metrics()
    
    # Sidebar controls: data actions + filters
    st.sidebar.header("Data & Pipeline Controls")
    col_generate, col_download = st.sidebar.columns(2)
    with col_generate:
        if st.button("Run Pipeline", help="Regenerate data, retrain models, and refresh dashboard outputs.", use_container_width=True):
            run_full_pipeline()
            # Clear caches so fresh data is used on next rerun
            load_dashboard_data.clear()
            load_raw_dataset.clear()
            compute_model_metrics.clear()
            st.rerun()
    with col_download:
        if base_df is not None:
            st.download_button(
                label="Download CSV",
                data=base_df.to_csv(index=False),
                file_name="delta_industries_machine_health.csv",
                mime="text/csv",
                help="Download the underlying machine health dataset.",
                use_container_width=True,
            )
        else:
            st.caption("Base dataset not found yet. Run the pipeline first.")
    
    # Sidebar filters
    st.sidebar.header("Filters")
    
    # Machine type filter
    machine_types = ['All'] + sorted(df['machine_type'].unique().tolist())
    selected_machine_type = st.sidebar.selectbox("Machine Type", machine_types)
    
    # Risk category filter
    risk_categories = ['All'] + sorted(df['risk_category'].unique().tolist())
    selected_risk = st.sidebar.selectbox("Risk Category", risk_categories)
    
    # Criticality filter
    criticality_scores = ['All'] + sorted(df['criticality_score'].unique().tolist())
    selected_criticality = st.sidebar.selectbox("Criticality Score", criticality_scores)
    
    # Failure flag filter
    failure_flag_filter = st.sidebar.selectbox("Failure Flag", ['All', 'Flagged (1)', 'Not Flagged (0)'])
    
    # Apply filters
    filtered_df = df.copy()
    if selected_machine_type != 'All':
        filtered_df = filtered_df[filtered_df['machine_type'] == selected_machine_type]
    if selected_risk != 'All':
        filtered_df = filtered_df[filtered_df['risk_category'] == selected_risk]
    if selected_criticality != 'All':
        filtered_df = filtered_df[filtered_df['criticality_score'] == selected_criticality]
    if failure_flag_filter == 'Flagged (1)':
        filtered_df = filtered_df[filtered_df['failure_flag'] == 1]
    elif failure_flag_filter == 'Not Flagged (0)':
        filtered_df = filtered_df[filtered_df['failure_flag'] == 0]
    
    # Information Cards Section
    st.markdown('<div class="section-header">Project Overview</div>', unsafe_allow_html=True)
    info_col1, info_col2, info_col3 = st.columns(3)
    
    with info_col1:
        st.markdown("""
        <div class="info-card">
            <h4>Dataset</h4>
            <p>Synthetic machine-health data for Delta Industries with weekly snapshots per machine. 
            Includes sensor readings (temperature, vibration, pressure, load factor), machine metadata 
            (type, age, maintenance history), and engineered targets for remaining useful life (RUL) 
            and 30-day failure risk prediction.</p>
        </div>
        """, unsafe_allow_html=True)
    
    with info_col2:
        st.markdown("""
        <div class="info-card">
            <h4>Models</h4>
            <p>Two complementary models: Linear Regression predicts continuous RUL in days for 
            maintenance planning, while Logistic Regression estimates binary failure probability 
            (within 30 days) for risk-based decision making. Both use scaled numerical features 
            and one-hot encoded machine types.</p>
        </div>
        """, unsafe_allow_html=True)
    
    with info_col3:
        st.markdown("""
        <div class="info-card">
            <h4>Business Logic</h4>
            <p>Risk categories: RED (urgent, failure_prob ≥ 70% or RUL ≤ 30 days), YELLOW 
            (schedule maintenance, failure_prob ≥ 40% or RUL ≤ 60 days), GREEN (monitor only). 
            Cost assumptions: $2,000 planned maintenance, $10,000 unplanned downtime, $5,000 
            emergency repair per machine.</p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Key Metrics Row
    st.markdown('<div class="section-header">Key Metrics</div>', unsafe_allow_html=True)
    
    # Get latest snapshot per machine for current status
    latest_snapshots = df.sort_values('snapshot_date').groupby('machine_id').last().reset_index()
    filtered_latest = filtered_df.sort_values('snapshot_date').groupby('machine_id').last().reset_index()
    
    col1, col2, col3, col4 = st.columns(4)
    
    # Total unique machines
    unique_machines = filtered_latest['machine_id'].nunique()
    total_unique_machines = latest_snapshots['machine_id'].nunique()
    
    with col1:
        st.metric("Total Machines", unique_machines, delta=f"{unique_machines - total_unique_machines}" if unique_machines != total_unique_machines else None)
    
    with col2:
        # Count machines currently in RED (latest snapshot per machine)
        red_current = filtered_latest[filtered_latest['risk_category'] == 'RED']
        red_count = len(red_current) if len(red_current) > 0 else 0
        total_red_current = len(latest_snapshots[latest_snapshots['risk_category'] == 'RED'])
        delta_val = red_count - total_red_current if red_count != total_red_current else None
        st.metric("At Risk (RED)", red_count, delta=f"{delta_val}" if delta_val is not None else None, 
                 help="Number of machines currently in RED status (based on latest snapshot per machine)")
    
    with col3:
        # Average RUL from latest snapshots
        avg_rul = filtered_latest['RUL_days_predicted'].mean()
        st.metric("Average RUL", f"{avg_rul:.1f} days", 
                 help="Average RUL across all machines (latest snapshot per machine)")
    
    with col4:
        # Average failure probability from latest snapshots
        avg_failure_prob = filtered_latest['failure_probability'].mean()
        st.metric("Avg Failure Probability", f"{avg_failure_prob:.1%}",
                 help="Average failure probability across all machines (latest snapshot per machine)")
    
    # Add context about current status
    if len(filtered_latest) > 0:
        yellow_count = len(filtered_latest[filtered_latest['risk_category'] == 'YELLOW'])
        green_count = len(filtered_latest[filtered_latest['risk_category'] == 'GREEN'])
        st.caption(f"Current Status Distribution: {red_count} RED | {yellow_count} YELLOW | {green_count} GREEN (based on latest snapshot per machine)")
    
    st.markdown("---")
    
    # Main Dashboard Sections
    # Row 1: RUL Overview and Failure Risk Distribution
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown('<div class="section-header">RUL Overview</div>', unsafe_allow_html=True)
        
        # RUL Distribution Histogram
        fig_rul_hist = px.histogram(
            filtered_df,
            x='RUL_days_predicted',
            nbins=30,
            title='RUL Distribution',
            labels={'RUL_days_predicted': 'Remaining Useful Life (Days)', 'count': 'Number of Snapshots'},
            color_discrete_sequence=['#667eea']
        )
        fig_rul_hist.add_vline(x=30, line_dash="dash", line_color="#d32f2f", annotation_text="30 days threshold", annotation_position="top")
        fig_rul_hist.add_vline(x=60, line_dash="dash", line_color="#f57c00", annotation_text="60 days threshold", annotation_position="top")
        fig_rul_hist.update_layout(
            height=400,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(size=13, color='#ffffff', family='Arial'),
            title_font=dict(size=16, color='#ffffff', family='Arial'),
            xaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff'), gridcolor='rgba(255,255,255,0.1)'),
            yaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff'), gridcolor='rgba(255,255,255,0.1)')
        )
        st.plotly_chart(fig_rul_hist, use_container_width=True)
        
        # RUL vs Actual RUL Comparison (if available)
        if 'actual_RUL_days' in filtered_df.columns:
            fig_rul_comparison = px.scatter(
                filtered_df,
                x='actual_RUL_days',
                y='RUL_days_predicted',
                color='risk_category',
                color_discrete_map={'RED': '#d32f2f', 'YELLOW': '#f57c00', 'GREEN': '#388e3c'},
                title='Predicted vs Actual RUL',
                labels={'actual_RUL_days': 'Actual RUL (Days)', 'RUL_days_predicted': 'Predicted RUL (Days)'},
                hover_data=['machine_id', 'failure_probability']
            )
            # Add diagonal line
            max_val = max(filtered_df['actual_RUL_days'].max(), filtered_df['RUL_days_predicted'].max())
            fig_rul_comparison.add_trace(go.Scatter(
                x=[0, max_val],
                y=[0, max_val],
                mode='lines',
                line=dict(dash='dash', color='gray', width=1),
                name='Perfect Prediction',
                showlegend=False
            ))
            fig_rul_comparison.update_layout(
                height=400,
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                font=dict(size=13, color='#ffffff', family='Arial'),
                title_font=dict(size=16, color='#ffffff', family='Arial'),
                xaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff'), gridcolor='rgba(255,255,255,0.1)'),
                yaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff'), gridcolor='rgba(255,255,255,0.1)'),
                legend=dict(font=dict(size=12, color='#ffffff'), bgcolor='rgba(0,0,0,0.5)')
            )
            st.plotly_chart(fig_rul_comparison, use_container_width=True)
    
    with col2:
        st.markdown('<div class="section-header">Failure Risk Distribution</div>', unsafe_allow_html=True)
        
        # Risk Category Pie Chart
        risk_counts = filtered_df['risk_category'].value_counts()
        fig_pie = px.pie(
            values=risk_counts.values,
            names=risk_counts.index,
            title='Risk Category Distribution',
            color=risk_counts.index,
            color_discrete_map={'RED': '#d32f2f', 'YELLOW': '#f57c00', 'GREEN': '#388e3c'}
        )
        fig_pie.update_layout(
            height=400,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(size=13, color='#ffffff', family='Arial'),
            title_font=dict(size=16, color='#ffffff', family='Arial'),
            legend=dict(font=dict(size=13, color='#ffffff'), bgcolor='rgba(0,0,0,0.5)')
        )
        st.plotly_chart(fig_pie, use_container_width=True)
        
        # Failure Probability Distribution
        fig_failure_prob = px.histogram(
            filtered_df,
            x='failure_probability',
            nbins=30,
            title='Failure Probability Distribution',
            labels={'failure_probability': 'Failure Probability', 'count': 'Number of Snapshots'},
            color='risk_category',
            color_discrete_map={'RED': '#d32f2f', 'YELLOW': '#f57c00', 'GREEN': '#388e3c'}
        )
        fig_failure_prob.add_vline(x=0.7, line_dash="dash", line_color="#d32f2f", annotation_text="70% threshold", annotation_position="top")
        fig_failure_prob.add_vline(x=0.4, line_dash="dash", line_color="#f57c00", annotation_text="40% threshold", annotation_position="top")
        fig_failure_prob.update_layout(
            height=400,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(size=13, color='#ffffff', family='Arial'),
            title_font=dict(size=16, color='#ffffff', family='Arial'),
            xaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff'), gridcolor='rgba(255,255,255,0.1)'),
            yaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff'), gridcolor='rgba(255,255,255,0.1)'),
            legend=dict(font=dict(size=12, color='#ffffff'), bgcolor='rgba(0,0,0,0.5)')
        )
        st.plotly_chart(fig_failure_prob, use_container_width=True)
    
    st.markdown("---")
    
    # Model Performance Summary
    if model_metrics is not None:
        st.markdown('<div class="section-header">Model Performance (Full Dataset)</div>', unsafe_allow_html=True)
        col_rul, col_fail = st.columns(2)

        with col_rul:
            st.markdown("**RUL Model (Linear Regression)**")
            st.metric("MAE", f"{model_metrics['rul']['mae']:.1f} days")
            st.metric("RMSE", f"{model_metrics['rul']['rmse']:.1f} days")
            st.metric("R²", f"{model_metrics['rul']['r2']:.3f}")

        with col_fail:
            st.markdown("**Failure Risk Model (Logistic Regression)**")
            st.metric("ROC-AUC", f"{model_metrics['failure']['auc']:.3f}")
            st.metric("Precision", f"{model_metrics['failure']['precision']:.3f}")
            st.metric("Recall", f"{model_metrics['failure']['recall']:.3f}")

        # Confusion matrix heatmap
        cm = model_metrics["failure"]["confusion_matrix"]
        cm_fig = px.imshow(
            cm,
            text_auto=True,
            color_continuous_scale="Blues",
            labels=dict(x="Predicted", y="Actual", color="Count"),
            x=["Low Risk (0)", "High Risk (1)"],
            y=["Low Risk (0)", "High Risk (1)"],
        )
        cm_fig.update_layout(
            title=dict(text="Failure Risk Model - Confusion Matrix", font=dict(size=16, color='#ffffff', family='Arial')),
            height=400,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(size=13, color='#ffffff', family='Arial'),
            xaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff')),
            yaxis=dict(title_font=dict(size=13, color='#ffffff'), tickfont=dict(size=12, color='#ffffff'))
        )
        st.plotly_chart(cm_fig, use_container_width=True)
        
        # Cost-Benefit Analysis
        st.markdown("---")
        st.markdown('<div class="section-header">Cost-Benefit Analysis</div>', unsafe_allow_html=True)
        
        cb = model_metrics['cost_benefit']
        total_costs = cb['planned_maintenance_cost'] + cb['missed_failures_cost']
        
        # Cost Assumptions Section
        st.markdown('<h3 style="color: #ffffff;">Cost Assumptions</h3>', unsafe_allow_html=True)
        assumption_col1, assumption_col2, assumption_col3 = st.columns(3)
        with assumption_col1:
            st.metric("Planned Maintenance", "$2,000", "per machine")
        with assumption_col2:
            st.metric("Unplanned Downtime", "$10,000", "per machine")
        with assumption_col3:
            st.metric("Emergency Repair", "$5,000", "per machine")
        
        st.markdown("---")
        
        # Costs and Savings Breakdown
        cost_col1, cost_col2 = st.columns(2)
        
        with cost_col1:
            st.markdown('<h4 style="color: #ffffff;">Costs Incurred</h4>', unsafe_allow_html=True)
            st.metric(
                "Planned Maintenance",
                f"${cb['planned_maintenance_cost']:,.0f}",
                help="Cost of maintenance for True Positives (TP) and False Positives (FP): ({} + {}) × $2,000".format(cb['tp'], cb['fp'])
            )
            st.metric(
                "Missed Failures Cost",
                f"${cb['missed_failures_cost']:,.0f}",
                help="Cost of unplanned downtime and emergency repair for False Negatives (FN): {} × ($10,000 + $5,000)".format(cb['fn'])
            )
            st.markdown("---")
            st.metric(
                "Total Costs",
                f"${total_costs:,.0f}",
                delta=None
            )
        
        with cost_col2:
            st.markdown('<h4 style="color: #ffffff;">Savings Generated</h4>', unsafe_allow_html=True)
            st.metric(
                "Prevented Downtime",
                f"${cb['prevented_downtime_savings']:,.0f}",
                help="Savings from preventing downtime for True Positives (TP): {} × $10,000".format(cb['tp'])
            )
            st.metric(
                "Total Savings",
                f"${cb['prevented_downtime_savings']:,.0f}",
                delta=None
            )
            st.markdown("---")
            net_benefit_color = "normal" if cb['net_benefit'] > 0 else "inverse"
            st.metric(
                "Net Benefit (ROI)",
                f"${cb['net_benefit']:,.0f}",
                delta=f"{'Positive' if cb['net_benefit'] > 0 else 'Negative'} ROI"
            )
        
        st.markdown("---")
        
        # Confusion Matrix Explanation
        st.markdown('<h3 style="color: #ffffff;">Model Performance Breakdown</h3>', unsafe_allow_html=True)
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Confusion Matrix Explanation:</strong> The confusion matrix shows how well the failure risk model classifies machines. 
            <strong>True Positives (TP):</strong> Machines correctly identified as high-risk - these are scheduled for maintenance, preventing downtime. 
            <strong>False Positives (FP):</strong> Machines incorrectly flagged as high-risk - these result in unnecessary maintenance costs. 
            <strong>False Negatives (FN):</strong> Machines incorrectly identified as low-risk - these are missed failures that lead to unplanned 
            downtime and emergency repairs. <strong>True Negatives (TN):</strong> Machines correctly identified as low-risk - no action needed, 
            saving maintenance costs. A good model maximizes TP and TN while minimizing FP and FN.</p>
        </div>
        """, unsafe_allow_html=True)
        confusion_col1, confusion_col2, confusion_col3, confusion_col4 = st.columns(4)
        
        with confusion_col1:
            st.metric("True Positives (TP)", cb['tp'], "Correctly identified failures")
        with confusion_col2:
            st.metric("False Positives (FP)", cb['fp'], "False alarms")
        with confusion_col3:
            st.metric("False Negatives (FN)", cb['fn'], "Missed failures")
        with confusion_col4:
            st.metric("True Negatives (TN)", cb['tn'], "Correctly identified safe machines")
        
        # ROI Status
        st.markdown("---")
        if cb['net_benefit'] > 0:
            st.success(f"**ROI Status: Positive** - The model provides significant value with a net benefit of ${cb['net_benefit']:,.0f}. The predictive maintenance system is cost-effective and should be implemented.")
        else:
            st.warning(f"**ROI Status: Needs Optimization** - Current net benefit is ${cb['net_benefit']:,.0f}. Consider adjusting prediction thresholds or improving model accuracy to increase cost savings.")
    else:
        st.info("Model performance metrics are not available yet. Run the full pipeline to train models and generate data.")
    
    st.markdown("---")
    
    # EDA Visualizations Section
    st.markdown('<div class="section-header">Exploratory Data Analysis Visualizations</div>', unsafe_allow_html=True)
    
    # Check if output images exist
    import os
    outputs_dir = 'outputs'
    
    # RUL Distribution
    if os.path.exists(f'{outputs_dir}/rul_distribution.png'):
        st.markdown("### RUL Distribution Analysis")
        st.image(f'{outputs_dir}/rul_distribution.png', use_container_width=True)
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Explanation:</strong> This histogram shows the distribution of Remaining Useful Life (RUL) values across all machine snapshots. 
            The chart helps identify how many machines are in critical (low RUL), warning (medium RUL), and safe (high RUL) states. 
            The box plot on the right compares RUL distributions between high-risk and low-risk machines, showing that machines with 
            higher failure risk tend to have lower RUL values, validating the predictive model's logic.</p>
        </div>
        """, unsafe_allow_html=True)
        st.markdown("---")
    
    # Failure Risk Distribution
    if os.path.exists(f'{outputs_dir}/failure_risk_distribution.png'):
        st.markdown("### Failure Risk Distribution")
        st.image(f'{outputs_dir}/failure_risk_distribution.png', use_container_width=True)
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Explanation:</strong> This visualization shows the binary distribution of failure risk (fail_in_30d: 0 = Low Risk, 1 = High Risk). 
            The bar chart and pie chart display the proportion of machines at high risk versus low risk. This helps understand the class balance 
            in the dataset. A balanced distribution ensures the model can learn from both failure and non-failure cases effectively.</p>
        </div>
        """, unsafe_allow_html=True)
        st.markdown("---")
    
    # Degradation Patterns
    if os.path.exists(f'{outputs_dir}/degradation_patterns.png'):
        st.markdown("### Machine Degradation Patterns")
        st.image(f'{outputs_dir}/degradation_patterns.png', use_container_width=True)
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Explanation:</strong> These four charts track how sensor values change as machines approach failure (RUL decreases). 
            <strong>Temperature:</strong> Increases as components degrade and generate more heat. <strong>Vibration:</strong> Increases due to bearing wear 
            and misalignment. <strong>Pressure:</strong> Decreases as seals degrade and leaks develop. <strong>Load Factor:</strong> Decreases as 
            machine efficiency degrades. These patterns demonstrate the physical relationships that the predictive models learn, showing that 
            sensor degradation is a reliable indicator of impending failure.</p>
        </div>
        """, unsafe_allow_html=True)
        st.markdown("---")
    
    # Correlation Heatmap
    if os.path.exists(f'{outputs_dir}/correlation_heatmap.png'):
        st.markdown("### Feature Correlation Analysis")
        st.image(f'{outputs_dir}/correlation_heatmap.png', use_container_width=True)
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Explanation:</strong> This heatmap shows correlations between all features and target variables (RUL_days and fail_in_30d). 
            Strong negative correlations (dark blue) with RUL indicate features that decrease as failure approaches (e.g., vibration_std_7d, 
            pressure_drop_pct_7d). Strong positive correlations (dark red) indicate features that increase with failure risk. This analysis 
            helps identify the most important predictive features and validates that the dataset follows logical physical relationships 
            between sensor readings and machine health.</p>
        </div>
        """, unsafe_allow_html=True)
        st.markdown("---")
    
    # Model Performance Visualization
    if os.path.exists(f'{outputs_dir}/model_performance.png'):
        st.markdown("### Model Performance Visualization")
        st.image(f'{outputs_dir}/model_performance.png', use_container_width=True)
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Explanation:</strong> This comprehensive visualization shows model performance across four key metrics. 
            <strong>Top Left - Actual vs Predicted RUL:</strong> Scatter plot showing how well the RUL model predicts actual values. 
            Points close to the diagonal line indicate accurate predictions. <strong>Top Right - RUL Residuals:</strong> Shows prediction errors 
            (actual - predicted). A random scatter around zero indicates good model fit. <strong>Bottom Left - Failure Probability Distribution:</strong> 
            Histogram showing how the failure risk model separates high-risk (red) from low-risk (green) machines. Good separation indicates 
            effective classification. <strong>Bottom Right - ROC Curve:</strong> Shows the trade-off between true positive rate and false positive 
            rate. A curve closer to the top-left corner indicates better model performance.</p>
        </div>
        """, unsafe_allow_html=True)
        st.markdown("---")
    
    # Add explanations for interactive charts
    st.markdown('<div class="section-header">Interactive Chart Explanations</div>', unsafe_allow_html=True)
    
    explanation_col1, explanation_col2 = st.columns(2)
    
    with explanation_col1:
        st.markdown("""
        <div class="explanation-box">
            <p><strong>RUL Distribution Histogram:</strong> Shows the frequency distribution of predicted RUL values. The red dashed line at 30 days 
            marks the critical threshold (urgent maintenance needed), and the orange line at 60 days marks the warning threshold (schedule 
            maintenance soon). This helps maintenance teams understand how many machines require immediate attention.</p>
        </div>
        """, unsafe_allow_html=True)
        
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Predicted vs Actual RUL Scatter Plot:</strong> Compares model predictions with actual RUL values. Points are color-coded by 
            risk category (RED, YELLOW, GREEN). Points close to the diagonal gray line indicate accurate predictions. This visualization helps 
            assess model accuracy and identify any systematic prediction errors.</p>
        </div>
        """, unsafe_allow_html=True)
    
    with explanation_col2:
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Risk Category Pie Chart:</strong> Shows the proportion of machines in each risk category (RED, YELLOW, GREEN). This gives 
            a quick overview of overall fleet health. A higher proportion of GREEN machines indicates a healthy fleet, while more RED machines 
            suggest urgent maintenance planning is needed.</p>
        </div>
        """, unsafe_allow_html=True)
        
        st.markdown("""
        <div class="explanation-box">
            <p><strong>Failure Probability Distribution:</strong> Histogram showing the distribution of predicted failure probabilities (0-100%). 
            The red dashed line at 70% marks the high-risk threshold, and the orange line at 40% marks the moderate-risk threshold. Machines with 
            probabilities above these thresholds are flagged for maintenance. This helps prioritize which machines need attention based on failure 
            likelihood.</p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Alert Panel - RED Category Machines
    st.markdown('<div class="section-header">Urgent Action Required (RED Category)</div>', unsafe_allow_html=True)
    
    # Get latest snapshot per machine for current status
    filtered_latest_snapshots = filtered_df.sort_values('snapshot_date').groupby('machine_id').last().reset_index()
    red_machines_current = filtered_latest_snapshots[filtered_latest_snapshots['risk_category'] == 'RED'].copy()
    
    if len(red_machines_current) > 0:
        # Sort by RUL (lowest first) and failure probability (highest first)
        red_machines_current = red_machines_current.sort_values(['RUL_days_predicted', 'failure_probability'], ascending=[True, False])
        
        # Display key metrics for RED machines
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total RED Machines", len(red_machines_current))
        with col2:
            st.metric("Lowest RUL", f"{red_machines_current['RUL_days_predicted'].min():.1f} days")
        with col3:
            st.metric("Highest Failure Prob", f"{red_machines_current['failure_probability'].max():.1%}")
        
        # Display table (already latest snapshot per machine)
        red_latest = red_machines_current.copy()
        display_cols = ['machine_id', 'machine_type', 'RUL_days_predicted', 'failure_probability', 
                       'criticality_score', 'snapshot_date']
        red_display = red_latest[display_cols].copy()
        red_display['RUL_days_predicted'] = red_display['RUL_days_predicted'].round(1)
        red_display['failure_probability'] = red_display['failure_probability'].apply(lambda x: f"{x:.1%}")
        red_display['snapshot_date'] = red_display['snapshot_date'].dt.strftime('%Y-%m-%d')
        red_display.columns = ['Machine ID', 'Machine Type', 'RUL (Days)', 'Failure Probability', 
                              'Criticality', 'Snapshot Date']
        
        st.dataframe(red_display, use_container_width=True, hide_index=True)
        
        # Action recommendations
        st.info("**Action Required:** Schedule maintenance within 1 week for these machines. Prepare spare parts and assign priority technicians.")
    else:
        st.success("No machines currently in RED category. All systems operating normally.")
    
    st.markdown("---")
    
    # Machine Details Table
    st.markdown('<div class="section-header">Machine Details Table</div>', unsafe_allow_html=True)
    
    # Sort options
    sort_by = st.selectbox("Sort by", ['RUL (Lowest First)', 'RUL (Highest First)', 
                                       'Failure Probability (Highest First)', 'Failure Probability (Lowest First)',
                                       'Machine ID', 'Risk Category'])
    
    display_df = filtered_df.copy()
    
    if sort_by == 'RUL (Lowest First)':
        display_df = display_df.sort_values('RUL_days_predicted', ascending=True)
    elif sort_by == 'RUL (Highest First)':
        display_df = display_df.sort_values('RUL_days_predicted', ascending=False)
    elif sort_by == 'Failure Probability (Highest First)':
        display_df = display_df.sort_values('failure_probability', ascending=False)
    elif sort_by == 'Failure Probability (Lowest First)':
        display_df = display_df.sort_values('failure_probability', ascending=True)
    elif sort_by == 'Machine ID':
        display_df = display_df.sort_values('machine_id', ascending=True)
    elif sort_by == 'Risk Category':
        risk_order = {'RED': 1, 'YELLOW': 2, 'GREEN': 3}
        display_df['risk_order'] = display_df['risk_category'].map(risk_order)
        display_df = display_df.sort_values('risk_order', ascending=True)
        display_df = display_df.drop('risk_order', axis=1)
    
    # Prepare display columns
    table_cols = ['machine_id', 'machine_type', 'RUL_days_predicted', 'failure_probability',
                  'risk_category', 'failure_flag', 'criticality_score', 'snapshot_date']
    if 'actual_RUL_days' in display_df.columns:
        table_cols.insert(4, 'actual_RUL_days')
    
    table_df = display_df[table_cols].copy()
    table_df['RUL_days_predicted'] = table_df['RUL_days_predicted'].round(1)
    table_df['failure_probability'] = table_df['failure_probability'].apply(lambda x: f"{x:.1%}")
    if 'actual_RUL_days' in table_df.columns:
        table_df['actual_RUL_days'] = table_df['actual_RUL_days'].round(1)
    table_df['snapshot_date'] = table_df['snapshot_date'].dt.strftime('%Y-%m-%d')
    
    # Rename columns for display
    column_mapping = {
        'machine_id': 'Machine ID',
        'machine_type': 'Machine Type',
        'RUL_days_predicted': 'RUL (Days)',
        'failure_probability': 'Failure Probability',
        'risk_category': 'Risk Category',
        'failure_flag': 'Failure Flag',
        'criticality_score': 'Criticality',
        'snapshot_date': 'Snapshot Date'
    }
    if 'actual_RUL_days' in table_df.columns:
        column_mapping['actual_RUL_days'] = 'Actual RUL (Days)'
    
    table_df = table_df.rename(columns=column_mapping)
    
    # Color code the dataframe
    def color_risk_category(val):
        if val == 'RED':
            return 'background-color: #ffebee'
        elif val == 'YELLOW':
            return 'background-color: #fff3e0'
        elif val == 'GREEN':
            return 'background-color: #e8f5e9'
        return ''
    
    styled_df = table_df.style.applymap(color_risk_category, subset=['Risk Category'])
    st.dataframe(styled_df, use_container_width=True, hide_index=True)
    
    st.markdown("---")
    
    # Maintenance Schedule
    st.markdown('<div class="section-header">Maintenance Schedule</div>', unsafe_allow_html=True)
    
    # Create maintenance schedule based on RUL
    schedule_df = filtered_df.copy()
    schedule_df['recommended_maintenance_date'] = pd.to_datetime(schedule_df['snapshot_date']) + pd.to_timedelta(schedule_df['RUL_days_predicted'], unit='D')
    # Use latest snapshot date as reference for "today" calculation
    latest_date = pd.to_datetime(schedule_df['snapshot_date'].max())
    schedule_df['days_until_maintenance'] = (schedule_df['recommended_maintenance_date'] - latest_date).dt.days
    
    # Sort by priority (RED first, then by RUL)
    risk_order = {'RED': 1, 'YELLOW': 2, 'GREEN': 3}
    schedule_df['risk_order'] = schedule_df['risk_category'].map(risk_order)
    schedule_df = schedule_df.sort_values(['risk_order', 'RUL_days_predicted'], ascending=[True, True])
    schedule_df = schedule_df.drop('risk_order', axis=1)
    
    # Show latest snapshot per machine
    schedule_latest = schedule_df.groupby('machine_id').first().reset_index()
    
    # Display schedule
    schedule_cols = ['machine_id', 'machine_type', 'RUL_days_predicted', 'failure_probability',
                    'risk_category', 'recommended_maintenance_date', 'days_until_maintenance']
    schedule_display = schedule_latest[schedule_cols].copy()
    schedule_display['RUL_days_predicted'] = schedule_display['RUL_days_predicted'].round(1)
    schedule_display['failure_probability'] = schedule_display['failure_probability'].apply(lambda x: f"{x:.1%}")
    schedule_display['recommended_maintenance_date'] = schedule_display['recommended_maintenance_date'].dt.strftime('%Y-%m-%d')
    schedule_display.columns = ['Machine ID', 'Machine Type', 'RUL (Days)', 'Failure Probability',
                                'Risk Category', 'Recommended Date', 'Days Until']
    
    st.dataframe(schedule_display.head(50), use_container_width=True, hide_index=True)
    
    st.info("**Note:** Recommended maintenance dates are calculated based on predicted RUL. Machines with RED category should be scheduled immediately.")
    
    # Footer
    st.markdown("---")
    st.markdown("**Delta Industries Ltd.** | Predictive Maintenance System | Generated for Project Evaluation")

if __name__ == "__main__":
    main()
